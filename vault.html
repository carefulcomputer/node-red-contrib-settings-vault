<!-- Config Node: vault-config -->
<style>
    /* Use Node-RED theme variables for proper theme support */
    .vault-entry-container {
        margin-bottom: 15px;
        padding: 12px;
        border: 1px solid var(--red-ui-form-input-border-color, #ccc);
        border-radius: 4px;
        background-color: var(--red-ui-secondary-background, #f6f6f6);
    }
    
    .vault-field-row, .property-row {
        margin-bottom: 8px;
        padding: 8px;
        border: 1px solid var(--red-ui-form-input-border-color, #ccc);
        border-radius: 4px;
        background-color: var(--red-ui-primary-background, #fff);
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    /* Flex sizing for field row children */
    .vault-field-row > span:first-child {
        flex-shrink: 0;
        min-width: 40px;
    }
    
    .vault-field-row > input.vault-field-name {
        flex: 0 0 150px;
        min-width: 100px;
    }
    
    .vault-field-row > div {
        flex: 1 1 auto;
        min-width: 200px;
    }
    
    .vault-field-row .validation-icon {
        flex-shrink: 0;
        min-width: 20px;
    }
    
    .vault-field-row > button {
        flex-shrink: 0;
    }
    
    .vault-field-row.validation-error, .property-row.validation-error {
        background-color: var(--red-ui-state-error-background, #ffe6e6);
    }
    
    .vault-header-row {
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .vault-fields-list {
        margin-left: 20px;
        margin-top: 10px;
    }
    
    .vault-properties-header {
        display: grid;
        grid-template-columns: 1.5fr 3fr 1.5fr 50px;
        gap: 10px;
        padding: 10px 12px;
        background: var(--red-ui-secondary-background, #f0f0f0);
        font-weight: 600;
        color: var(--red-ui-primary-text-color, #555);
        border-radius: 4px 4px 0 0;
        margin-bottom: 5px;
    }
    
    .validation-icon, .property-validation-icon {
        min-width: 20px;
        text-align: center;
    }
    
    .validation-icon .fa-check {
        color: var(--red-ui-state-success, #5a6);
    }
    
    .validation-icon .fa-exclamation-triangle {
        color: var(--red-ui-state-error, #c00);
    }
    
    /* Flex sizing for property row children */
    .property-row > select {
        flex: 0 0 150px;
        min-width: 100px;
    }
    
    .property-row > div {
        flex: 1 1 auto;
        min-width: 150px;
    }
    
    .property-row .property-validation-icon {
        flex-shrink: 0;
        min-width: 20px;
    }
    
    .property-row > button {
        flex-shrink: 0;
    }
    
    /* Make TypedInput widgets fill available space */
    .vault-field-row .red-ui-typedInput-container,
    .property-row .red-ui-typedInput-container {
        width: 100% !important;
    }
</style>

<script type="text/javascript">
    RED.nodes.registerType('vault-config', {
        category: 'config',
        defaults: {
            name: { value: '', required: true },
            structure: { value: {} }
        },
        credentials: {
            store: { type: 'text' }
        },
        label: function() {
            return this.name || 'vault-config';
        },
        oneditprepare: function() {
            const node = this;
            let entryCount = 0;
            let fieldCounters = {};
            
            // Parse existing vault store and populate entries
            function loadEntries() {
                // Get existing vault data
                let storeValue = (node.credentials && node.credentials.store) ? node.credentials.store : '{}';
                let entries = {};
                
                try {
                    if (storeValue && storeValue.trim() !== '' && storeValue !== '{}') {
                        entries = JSON.parse(storeValue);
                    }
                } catch (err) {
                    RED.notify('Failed to parse existing vault data: ' + err.message, 'warning');
                    entries = {};
                }
                
                // Clear existing entries UI
                $('#vault-entries-list').empty();
                entryCount = 0;
                fieldCounters = {};
                
                // Populate entries from vault
                let isFirstEntry = true;
                for (const key in entries) {
                    if (entries.hasOwnProperty(key)) {
                        // First entry should be expanded for better zero state
                        addEntryRow(key, entries[key], !isFirstEntry);
                        isFirstEntry = false;
                    }
                }
                
                // Add one empty row if no entries exist (expanded for zero state)
                if (entryCount === 0) {
                    addEntryRow('', {}, false);
                }
            }
            
            // Add a new vault entry (key with multiple fields)
            // collapseByDefault: true to collapse, false to show expanded
            function addEntryRow(key, credentialsObj, collapseByDefault) {
                const entryId = 'vault-entry-' + entryCount;
                entryCount++;
                fieldCounters[entryId] = 0;
                
                // Default to collapsed unless explicitly set to false
                if (collapseByDefault === undefined) {
                    collapseByDefault = true;
                }
                
                const entryContainer = $('<div>', {
                    id: entryId,
                    class: 'vault-entry-container'
                });
                
                // Entry header with key, collapse/expand, clone, and delete buttons
                const headerRow = $('<div>', {
                    class: 'vault-header-row'
                });
                
                // Collapse/Expand toggle
                const toggleBtn = $('<button>', {
                    type: 'button',
                    class: 'red-ui-button vault-toggle-btn'
                }).html('<i class="fa fa-chevron-right"></i>').on('click', function() {
                    const isCollapsed = entryContainer.hasClass('collapsed');
                    if (isCollapsed) {
                        entryContainer.removeClass('collapsed');
                        $(this).html('<i class="fa fa-chevron-down"></i>');
                        entryContainer.find('.vault-fields-list, .add-field-btn').show();
                    } else {
                        entryContainer.addClass('collapsed');
                        $(this).html('<i class="fa fa-chevron-right"></i>');
                        entryContainer.find('.vault-fields-list, .add-field-btn').hide();
                    }
                });
                
                const keyLabel = $('<label>').text('Group:');
                
                const keyInput = $('<input>', {
                    type: 'text',
                    class: 'vault-entry-key',
                    value: key,
                    placeholder: 'e.g. apiService'
                });
                
                const cloneEntryBtn = $('<button>', {
                    type: 'button',
                    class: 'red-ui-button',
                    title: 'Clone this group'
                }).html('<i class="fa fa-copy"></i> Clone').on('click', function() {
                    // Clone the group with new key
                    const originalKey = entryContainer.find('.vault-entry-key').val();
                    const newKey = originalKey + '_copy';
                    
                    // Collect all fields from current entry
                    const fields = {};
                    entryContainer.find('.vault-field-row').each(function() {
                        const fieldRow = $(this);
                        const fieldName = fieldRow.find('.vault-field-name').val();
                        const fieldType = fieldRow.find('.vault-field-value').typedInput('type');
                        const fieldValue = fieldRow.find('.vault-field-value').typedInput('value');
                        
                        if (fieldName) {
                            // Store value with type metadata
                            fields[fieldName] = {
                                value: fieldValue,
                                type: fieldType
                            };
                        }
                    });
                    
                    // Create new entry with cloned data (collapsed by default)
                    addEntryRow(newKey, fields, true);
                    RED.notify('Entry cloned as "' + newKey + '"', 'success');
                });
                
                const deleteEntryBtn = $('<button>', {
                    type: 'button',
                    class: 'red-ui-button'
                }).html('<i class="fa fa-trash"></i> Delete Group').on('click', function() {
                    const entryKey = keyInput.val() || 'this entry';
                    const fieldCount = entryContainer.find('.vault-field-row').length;
                    
                    if (confirm('Delete "' + entryKey + '" with ' + fieldCount + ' field(s)?')) {
                        entryContainer.remove();
                        RED.notify('Entry deleted', 'success');
                    }
                });
                
                headerRow.append(toggleBtn).append(keyLabel).append(keyInput).append(cloneEntryBtn).append(deleteEntryBtn);
                
                // Fields list container
                const fieldsList = $('<div>', {
                    class: 'vault-fields-list'
                });
                
                // Add field button
                const addFieldBtn = $('<button>', {
                    type: 'button',
                    class: 'red-ui-button add-field-btn'
                }).html('<i class="fa fa-plus"></i> Add Field').on('click', function() {
                    addFieldRow(entryId, fieldsList, '', 'str', '');
                });
                
                // Assemble entry
                entryContainer.append(headerRow).append(fieldsList).append(addFieldBtn);
                $('#vault-entries-list').append(entryContainer);
                
                // Populate existing fields
                if (credentialsObj && typeof credentialsObj === 'object') {
                    for (const fieldName in credentialsObj) {
                        if (credentialsObj.hasOwnProperty(fieldName)) {
                            const fieldData = credentialsObj[fieldName];
                            const type = detectType(fieldData);
                            const value = extractValue(fieldData);
                            addFieldRow(entryId, fieldsList, fieldName, type, value);
                        }
                    }
                }
                
                // Add one empty field if no fields exist
                if (fieldsList.children().length === 0) {
                    addFieldRow(entryId, fieldsList, '', 'str', '');
                }
                
                // Collapse entry by default (if configured)
                if (collapseByDefault) {
                    entryContainer.addClass('collapsed');
                    toggleBtn.html('<i class="fa fa-chevron-right"></i>');
                    fieldsList.hide();
                    addFieldBtn.hide();
                } else {
                    // Entry starts expanded
                    toggleBtn.html('<i class="fa fa-chevron-down"></i>');
                    fieldsList.show();
                    addFieldBtn.show();
                }
            }
            
            // Detect type from stored field data
            // New format: {value: actualValue, type: 'str'|'cred'|'num'|'bool'|'json'|'date'}
            // Legacy format: just the raw value (for backward compatibility detection only)
            function detectType(fieldData) {
                // New format must have BOTH 'value' and 'type' properties
                // This prevents false positives with legacy JSON objects that happen to have 'type' property
                if (fieldData && 
                    typeof fieldData === 'object' && 
                    fieldData.hasOwnProperty('type') && 
                    fieldData.hasOwnProperty('value')) {
                    return fieldData.type;
                }
                
                // Legacy format - detect from value (for old vaults)
                const value = fieldData;
                if (value === null || value === undefined) return 'str';
                if (typeof value === 'number') return 'num';
                if (typeof value === 'boolean') return 'bool';
                if (value instanceof Date) return 'date';
                if (typeof value === 'object') return 'json';
                return 'str';
            }
            
            // Extract value from stored field data
            function extractValue(fieldData) {
                // New format must have BOTH 'value' and 'type' properties
                if (fieldData && 
                    typeof fieldData === 'object' && 
                    fieldData.hasOwnProperty('value') && 
                    fieldData.hasOwnProperty('type')) {
                    return fieldData.value;
                }
                // Legacy format - return as-is
                return fieldData;
            }
            
            // Add a credential field within an entry
            function addFieldRow(entryId, fieldsList, fieldName, fieldType, fieldValue) {
                const fieldId = entryId + '-field-' + fieldCounters[entryId];
                fieldCounters[entryId]++;
                
                const fieldRow = $('<div>', {
                    id: fieldId,
                    class: 'vault-field-row'
                });
                
                // Field name input
                const fieldNameLabel = $('<span>').text('Field:');
                
                const fieldNameInput = $('<input>', {
                    type: 'text',
                    class: 'vault-field-name',
                    value: fieldName,
                    placeholder: 'e.g. username'
                });
                
                // TypedInput for value
                const valueInputContainer = $('<div>');
                
                const valueInput = $('<input>', {
                    type: 'text',
                    class: 'vault-field-value'
                });
                
                valueInputContainer.append(valueInput);
                
                // Validation indicator
                const validationIcon = $('<span>', {
                    class: 'validation-icon'
                }).html('');
                
                // Delete field button
                const deleteFieldBtn = $('<button>', {
                    type: 'button',
                    class: 'red-ui-button red-ui-button-small'
                }).html('<i class="fa fa-times"></i>').on('click', function() {
                    const fieldName = fieldNameInput.val() || 'this field';
                    if (fieldNameInput.val() || valueInput.typedInput('value')) {
                        if (confirm('Delete field "' + fieldName + '"?')) {
                            fieldRow.remove();
                        }
                    } else {
                        fieldRow.remove();
                    }
                });
                
                // Assemble field row
                fieldRow.append(fieldNameLabel).append(fieldNameInput).append(valueInputContainer).append(validationIcon).append(deleteFieldBtn);
                fieldsList.append(fieldRow);
                
                // Initialize TypedInput widget with cred type for masked inputs
                valueInput.typedInput({
                    types: ['str', 'cred', 'num', 'bool', 'json', 'date'],
                    default: fieldType || 'str',
                    typeField: '#' + valueInput.attr('id') + '-type'
                });
                
                // Set initial value and type
                valueInput.typedInput('type', fieldType || 'str');
                if (fieldValue !== undefined && fieldValue !== null) {
                    if (fieldType === 'json') {
                        valueInput.typedInput('value', JSON.stringify(fieldValue));
                    } else {
                        valueInput.typedInput('value', String(fieldValue));
                    }
                }
                
                // Add inline validation
                function validateField() {
                    const fieldName = fieldNameInput.val().trim();
                    const currentType = valueInput.typedInput('type');
                    const currentValue = valueInput.typedInput('value');
                    
                    let isValid = true;
                    let errorMsg = '';
                    
                    // Skip validation for empty fields
                    if (!fieldName && !currentValue) {
                        validationIcon.html('');
                        fieldRow.removeClass('validation-error');
                        return;
                    }
                    
                    // Validate field name
                    if (!fieldName && currentValue) {
                        isValid = false;
                        errorMsg = 'Field name required';
                    }
                    
                    // Validate value based on type
                    if (fieldName && currentValue) {
                        try {
                            switch (currentType) {
                                case 'num':
                                    if (isNaN(Number(currentValue))) {
                                        isValid = false;
                                        errorMsg = 'Invalid number';
                                    }
                                    break;
                                case 'bool':
                                    if (currentValue !== 'true' && currentValue !== 'false' && 
                                        currentValue !== true && currentValue !== false) {
                                        isValid = false;
                                        errorMsg = 'Must be true or false';
                                    }
                                    break;
                                case 'json':
                                    try {
                                        JSON.parse(currentValue);
                                    } catch (e) {
                                        isValid = false;
                                        errorMsg = 'Invalid JSON: ' + e.message;
                                    }
                                    break;
                            }
                        } catch (e) {
                            isValid = false;
                            errorMsg = 'Validation error';
                        }
                    }
                    
                    // Update UI
                    if (isValid && fieldName && currentValue) {
                        validationIcon.html('<i class="fa fa-check" title="Valid"></i>');
                        fieldRow.removeClass('validation-error');
                    } else if (!isValid) {
                        validationIcon.html('<i class="fa fa-exclamation-triangle" title="' + errorMsg + '"></i>');
                        fieldRow.addClass('validation-error');
                    } else {
                        validationIcon.html('');
                        fieldRow.removeClass('validation-error');
                    }
                }
                
                // Attach validation to field name input
                fieldNameInput.on('input', validateField);
                
                // Attach validation to value changes
                valueInput.on('change', function() {
                    setTimeout(validateField, 100);
                });
                
                // Run initial validation
                setTimeout(validateField, 100);
            }
            
            // Add entry button handler
            $('#vault-add-entry').on('click', function() {
                // New entries should be expanded so user can immediately fill them
                addEntryRow('', {}, false);
            });
            
            // Load existing entries
            loadEntries();
        },
        oneditsave: function() {
            const vault = {};
            let hasError = false;
            
            // Collect all entries from UI
            $('.vault-entry-container').each(function() {
                const entryContainer = $(this);
                const key = entryContainer.find('.vault-entry-key').val().trim();
                
                // Skip entries with empty key and no fields
                const hasFields = entryContainer.find('.vault-field-row').length > 0;
                if (key === '' && !hasFields) {
                    return; // Skip this entry
                }
                
                // Validate key is provided
                if (key === '') {
                    RED.notify('Entry with empty key found. Please provide a key or delete the entry.', 'error');
                    hasError = true;
                    return false;
                }
                
                // Check for duplicate keys
                if (vault.hasOwnProperty(key)) {
                    RED.notify('Duplicate key found: "' + key + '". Keys must be unique.', 'error');
                    hasError = true;
                    return false;
                }
                
                // Collect all fields within this entry
                const credentials = {};
                let hasFieldError = false;
                
                entryContainer.find('.vault-field-row').each(function() {
                    const fieldRow = $(this);
                    const fieldName = fieldRow.find('.vault-field-name').val().trim();
                    const valueInput = fieldRow.find('.vault-field-value');
                    
                    // Skip empty fields
                    if (fieldName === '' && valueInput.typedInput('value') === '') {
                        return; // Skip this field
                    }
                    
                    // Validate field name is provided
                    if (fieldName === '') {
                        RED.notify('Entry "' + key + '" has a field with no name. Please provide a field name or delete the field.', 'error');
                        hasFieldError = true;
                        return false;
                    }
                    
                    // Check for duplicate field names within this entry
                    if (credentials.hasOwnProperty(fieldName)) {
                        RED.notify('Entry "' + key + '" has duplicate field name: "' + fieldName + '".', 'error');
                        hasFieldError = true;
                        return false;
                    }
                    
                    // Get value and type from TypedInput
                    const fieldType = valueInput.typedInput('type');
                    let fieldValue = valueInput.typedInput('value');
                    
                    // Convert value based on type
                    try {
                        switch (fieldType) {
                            case 'num':
                                fieldValue = Number(fieldValue);
                                if (isNaN(fieldValue)) {
                                    throw new Error('Invalid number');
                                }
                                break;
                            case 'bool':
                                if (fieldValue === 'true' || fieldValue === true) {
                                    fieldValue = true;
                                } else if (fieldValue === 'false' || fieldValue === false) {
                                    fieldValue = false;
                                } else {
                                    throw new Error('Invalid boolean (must be true or false)');
                                }
                                break;
                            case 'json':
                                fieldValue = JSON.parse(fieldValue);
                                break;
                            case 'date':
                                // TypedInput for date returns timestamp
                                fieldValue = Number(fieldValue);
                                break;
                            case 'cred':
                            case 'str':
                            default:
                                // Keep as string (cred stored same as str, just masked in UI)
                                break;
                        }
                        
                        // Store value with type metadata
                        credentials[fieldName] = {
                            value: fieldValue,
                            type: fieldType
                        };
                    } catch (err) {
                        RED.notify('Invalid value for field "' + fieldName + '" in entry "' + key + '": ' + err.message, 'error');
                        hasFieldError = true;
                        return false;
                    }
                });
                
                if (hasFieldError) {
                    hasError = true;
                    return false;
                }
                
                vault[key] = credentials;
            });
            
            if (hasError) {
                return false;
            }
            
            // Auto-generate structure from vault (group names and property names)
            // This allows vault runtime nodes to populate dropdowns without loading credentials
            const structure = {};
            Object.keys(vault).forEach(function(groupName) {
                structure[groupName] = Object.keys(vault[groupName]);
            });
            this.structure = structure;
            
            // Save vault as JSON string
            $('#node-config-input-store').val(JSON.stringify(vault));
        }
    });
</script>

<script type="text/html" data-template-name="vault-config">
    <div class="form-row">
        <label for="node-config-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-config-input-name" placeholder="Vault name">
    </div>
    
    <div class="form-row">
        <label style="width: 100%;"><i class="fa fa-lock"></i> Vault Entries</label>
        <div style="width: 100%; max-height: 500px; overflow-y: auto;">
            <div id="vault-entries-list" style="margin-top: 10px; width: 100%;"></div>
            
            <div style="margin-top: 10px;">
                <button type="button" id="vault-add-entry" class="red-ui-button">
                    <i class="fa fa-plus"></i> Add Group
                </button>
            </div>
            
            <div class="form-tips" style="margin-top: 15px;">
                <strong>What is this?</strong> This configuration node stores your settings in one secure, encrypted location. No external dependencies - uses Node-RED's built-in encryption.
                <br><br>
                <strong>How it works:</strong> Organize settings into <strong>Groups</strong> (logical groupings) containing <strong>Properties</strong> (individual values).
                <br><br>
                <strong>Example:</strong> Group "apiService" might contain properties: baseUrl ("https://api.example.com"), apiKey (your key), timeout (30000). Use <strong>cred</strong> type for sensitive values to mask them in the editor.
            </div>
        </div>
    </div>
    
    <!-- Hidden field to store the actual JSON -->
    <input type="hidden" id="node-config-input-store">
</script>

<script type="text/html" data-help-name="vault-config">
    <p>Configuration node for centralized storage of credentials, API endpoints, database settings, feature flags, and any other configuration values. All values are encrypted using Node-RED's built-in credential system with no external dependencies.</p>
    
    <h3>Properties</h3>
    <dl class="message-properties">
        <dt>Name <span class="property-type">string</span></dt>
        <dd>A descriptive name for this vault instance (e.g., "Production Settings", "Test Configuration").</dd>
        
        <dt>Groups <span class="property-type">array</span></dt>
        <dd>A list of configuration groups. Each group contains related settings:
            <ul>
                <li><strong>Group:</strong> A logical grouping (e.g., "apiService", "database", "features")</li>
                <li><strong>Properties:</strong> Multiple properties with:
                    <ul>
                        <li><strong>Property Name:</strong> Setting name (e.g., "baseUrl", "timeout", "enabled")</li>
                        <li><strong>Type:</strong> Data type (str, cred, num, bool, json, date)</li>
                        <li><strong>Value:</strong> The configuration value (all types encrypted at rest)</li>
                    </ul>
                </li>
            </ul>
        </dd>
    </dl>
    
    <h3>Supported Types</h3>
    <ul>
        <li><strong>str</strong> - Text values (URLs, hostnames, usernames, tokens, base64 encoded data)</li>
        <li><strong>cred</strong> - Masked input for credentials, API keys, secrets</li>
        <li><strong>num</strong> - Numbers (ports, timeouts, thresholds, limits)</li>
        <li><strong>bool</strong> - Boolean flags (enabled/disabled, feature flags)</li>
        <li><strong>json</strong> - Complex data (nested objects, arrays, configurations)</li>
        <li><strong>date</strong> - Timestamps (expiration dates, schedule times)</li>
    </ul>
    <p><strong>Note:</strong> All values are encrypted at rest using Node-RED's built-in encryption. No external dependencies required. Use <strong>cred</strong> type for masked editor input.</p>
    
    <h3>Details</h3>
    <p>This node stores all configuration values in a single encrypted field using Node-RED's built-in credential encryption. The vault content is stored in <code>flows_cred.json</code> and never appears in plain text in <code>flows.json</code>.</p>
    
    <p>The vault is <strong>read-only at runtime</strong>. To add, modify, or delete configuration values, edit this configuration node and redeploy the flow.</p>
    
    <p><strong>Use Cases:</strong></p>
    <ul>
        <li>Store credentials (usernames, API keys, secrets)</li>
        <li>Manage API endpoints and base URLs</li>
        <li>Configure database connection settings</li>
        <li>Control feature flags and environment settings</li>
        <li>Set operational thresholds and timeouts</li>
        <li>Maintain separate configurations for dev/staging/production</li>
    </ul>
    
    <h3>Usage</h3>
    <ol>
        <li>Click <strong>"Add Group"</strong> to create a new vault group</li>
        <li>Enter a unique group name (e.g., "apiService", "database")</li>
        <li>Click <strong>"Add Field"</strong> to add properties within the group</li>
        <li>For each property, enter:
            <ul>
                <li>Property name (e.g., "username", "password", "port")</li>
                <li>Type from dropdown (str, cred, num, bool, json, date)</li>
                <li>Value (visible in editor for most types, masked for cred type, encrypted when saved)</li>
            </ul>
        </li>
        <li>Use <strong>"Ã—"</strong> to remove individual properties or <strong>"Delete Group"</strong> for entire groups</li>
        <li>Click <strong>"Update"</strong> to validate and save all changes</li>
    </ol>
    
    <h3>Example: API Service Configuration</h3>
    <p>Group: <code>apiService</code></p>
    <ul>
        <li>Property: <code>baseUrl</code>, Type: <code>str</code>, Value: <code>https://api.production.com</code></li>
        <li>Property: <code>apiKey</code>, Type: <code>cred</code>, Value: <code>sk_live_abc123</code></li>
        <li>Property: <code>timeout</code>, Type: <code>num</code>, Value: <code>30000</code></li>
        <li>Property: <code>retryEnabled</code>, Type: <code>bool</code>, Value: <code>true</code></li>
    </ul>
    
    <h3>Example: Feature Flags</h3>
    <p>Group: <code>features</code></p>
    <ul>
        <li>Property: <code>maintenanceMode</code>, Type: <code>bool</code>, Value: <code>false</code></li>
        <li>Property: <code>debugLogging</code>, Type: <code>bool</code>, Value: <code>false</code></li>
        <li>Property: <code>rateLimitPerMinute</code>, Type: <code>num</code>, Value: <code>100</code></li>
        <li>Property: <code>allowedRegions</code>, Type: <code>json</code>, Value: <code>["us-east","eu-west"]</code></li>
    </ul>
    
    <h3>Using in Function Nodes</h3>
    <p>Vault values can be accessed directly from function nodes using the global vault function:</p>
    
    <h4>Basic Usage:</h4>
    <pre>// Get vault function (at top of function node)
const vault = global.get('vault');

// Access values
const apiKey = vault('Production Settings')
    .getGroup('apiService')
    .getProperty('apiKey');</pre>
    
    <h4>Advanced Patterns:</h4>
    <pre>// Direct property access
const db = vault('Prod').getGroup('database');
const connection = db.host + ':' + db.port;

// Destructuring
const { host, port } = vault('Prod').getGroup('database');

// Get all properties (clean copy)
const config = vault('Prod').getGroup('apiService').getAll();</pre>
    
    <p><strong>Methods:</strong></p>
    <ul>
        <li><code>.getGroup(name)</code> - Returns group data object with methods</li>
        <li><code>.getProperty(name)</code> - Returns single property value (throws error if missing)</li>
        <li><code>.getAll()</code> - Returns clean copy of all group properties without methods</li>
        <li>Direct property access - Returns value or undefined (no error)</li>
    </ul>
    
    <p>See the main documentation for complete examples and error handling patterns.</p>
</script>


<!-- Runtime Node: vault -->
<script type="text/javascript">
    RED.nodes.registerType('vault', {
        category: 'function',
        color: '#3FADB5',
        defaults: {
            name: { value: '' },
            vault: { value: '', type: 'vault-config', required: true },
            properties: { value: [] }
        },
        inputs: 1,
        outputs: 1,
        icon: 'font-awesome/fa-key',
        label: function() {
            return this.name || 'vault';
        },
        labelStyle: function() {
            return this.name ? 'node_label_italic' : '';
        },
        oneditprepare: function() {
            const node = this;
            let propertyRowCount = 0;
            
            // Load available groups from selected vault
            function loadAvailableGroups(vaultId) {
                // Use provided vaultId, or try DOM, then fallback to node.vault
                if (!vaultId) {
                    vaultId = $('#node-input-vault').val() || node.vault;
                }
                if (!vaultId) {
                    return [];
                }
                
                const vaultNode = RED.nodes.node(vaultId);
                if (!vaultNode || !vaultNode.structure) {
                    return [];
                }
                
                // Return group names from structure
                return Object.keys(vaultNode.structure);
            }
            
            // Load available properties for a given group
            function loadPropertiesForGroup(groupName, vaultId) {
                // Use provided vaultId, or try DOM, then fallback to node.vault
                if (!vaultId) {
                    vaultId = $('#node-input-vault').val() || node.vault;
                }
                if (!vaultId || !groupName) {
                    return [];
                }
                
                const vaultNode = RED.nodes.node(vaultId);
                if (!vaultNode || !vaultNode.structure) {
                    return [];
                }
                
                // Return property names for the specified group from structure
                return vaultNode.structure[groupName] || [];
            }
            
            // Create group dropdown
            function createGroupSelect(selectedGroup, vaultId) {
                const select = $('<select>');
                const groups = loadAvailableGroups(vaultId);
                
                select.append($('<option>', { value: '' }).text('-- select group --'));
                
                // If we have a selected group but no groups loaded, add the selected group anyway
                // (This can happen if structure isn't available yet)
                if (selectedGroup && groups.length === 0) {
                    select.append($('<option>', { value: selectedGroup, selected: true }).text(selectedGroup));
                } else {
                    groups.forEach(group => {
                        select.append($('<option>', { value: group, selected: group === selectedGroup }).text(group));
                    });
                }
                
                return select;
            }
            
            // Create property dropdown
            function createPropertySelect(groupName, selectedProperty, vaultId) {
                const select = $('<select>');
                const properties = loadPropertiesForGroup(groupName, vaultId);
                
                select.append($('<option>', { value: '' }).text('-- select property --'));
                
                // If we have a selected property but no properties loaded, add the selected property anyway
                // (This can happen if structure isn't available yet)
                if (selectedProperty && properties.length === 0) {
                    select.append($('<option>', { value: selectedProperty, selected: true }).text(selectedProperty));
                } else {
                    properties.forEach(prop => {
                        select.append($('<option>', { value: prop, selected: prop === selectedProperty }).text(prop));
                    });
                }
                
                return select;
            }
            
            // Add a property row
            function addPropertyRow(group, property, output, vaultId) {
                const rowId = 'property-row-' + propertyRowCount++;
                
                // Use provided vaultId or fallback to node.vault
                if (!vaultId) {
                    vaultId = node.vault;
                }
                
                const row = $('<div>', {
                    id: rowId,
                    class: 'property-row'
                });
                
                // Group dropdown
                const groupSelect = createGroupSelect(group, vaultId);
                groupSelect.css('flex', '1');
                row.append(groupSelect);
                
                // Property dropdown (using let so we can update the reference)
                let propertySelect = createPropertySelect(group, property, vaultId);
                propertySelect.css('flex', '1');
                row.append(propertySelect);
                
                // Update property dropdown when group changes
                groupSelect.on('change', function() {
                    const newGroup = $(this).val();
                    const newPropertySelect = createPropertySelect(newGroup, '', vaultId);
                    newPropertySelect.css('flex', '1');
                    
                    // Remove old handlers and replace in DOM
                    propertySelect.off();
                    propertySelect.replaceWith(newPropertySelect);
                    
                    // Update reference to point to the new select
                    propertySelect = newPropertySelect;
                    
                    // Trigger validation immediately
                    if (node._validateAndUpdateButton) {
                        node._validateAndUpdateButton();
                    }
                    
                    // Update output field when new property is selected
                    // IMPORTANT: Wait for TypedInput initialization before attaching handler
                    setTimeout(function() {
                        newPropertySelect.on('change', function() {
                            const propValue = $(this).val();
                            const outputInput = row.find('.property-output');
                            if (propValue && !outputInput.data('userModified')) {
                                outputInput.typedInput('value', propValue);
                            }
                            // Trigger validation on property change
                            if (node._validateAndUpdateButton) {
                                node._validateAndUpdateButton();
                            }
                        });
                    }, 10); // Small delay to ensure TypedInput is ready
                });
                
                // Output field container with TypedInput (msg/flow/global)
                const outputContainer = $('<div>');
                
                const outputInput = $('<input>', {
                    type: 'text',
                    class: 'property-output'
                });
                
                outputContainer.append(outputInput);
                row.append(outputContainer);
                
                // Validation indicator
                const validationIcon = $('<span>', {
                    class: 'property-validation-icon'
                }).html('');
                row.append(validationIcon);
                
                // Initialize TypedInput after adding to DOM
                setTimeout(function() {
                    outputInput.typedInput({
                        types: ['msg', 'flow', 'global'],
                        default: 'msg'
                    });
                    
                    // Set initial value
                    if (output) {
                        // Parse output like "msg.username" or "flow.apiKey"
                        const parts = output.split('.');
                        if (parts.length >= 2 && (parts[0] === 'msg' || parts[0] === 'flow' || parts[0] === 'global')) {
                            outputInput.typedInput('type', parts[0]);
                            outputInput.typedInput('value', parts.slice(1).join('.'));
                        } else {
                            outputInput.typedInput('value', property || '');
                        }
                    } else {
                        outputInput.typedInput('value', property || '');
                    }
                    
                    // Track manual modifications and trigger validation
                    outputInput.on('change', function() {
                        $(this).data('userModified', true);
                        // Trigger validation check
                        if (node._validateAndUpdateButton) {
                            node._validateAndUpdateButton();
                        }
                    });
                    
                    // Auto-fill output when property is selected
                    // IMPORTANT: This must be inside setTimeout to ensure TypedInput is initialized
                    propertySelect.on('change', function() {
                        const propValue = $(this).val();
                        if (propValue && !outputInput.data('userModified')) {
                            outputInput.typedInput('value', propValue);
                        }
                        // Trigger validation on property change
                        if (node._validateAndUpdateButton) {
                            node._validateAndUpdateButton();
                        }
                    });
                }, 0);
                
                // Delete button
                const deleteBtn = $('<button>', {
                    type: 'button',
                    class: 'red-ui-button red-ui-button-small property-delete-btn'
                }).html('<i class="fa fa-times"></i>').on('click', function() {
                    row.remove();
                    updateDeleteButtons();
                    // Trigger validation after deletion
                    if (node._validateAndUpdateButton) {
                        node._validateAndUpdateButton();
                    }
                });
                
                row.append(deleteBtn);
                
                $('#properties-list').append(row);
                updateDeleteButtons();
            }
            
            // Update delete button states
            function updateDeleteButtons() {
                const rows = $('.property-row');
                $('.property-delete-btn').each(function(index) {
                    if (rows.length === 1) {
                        $(this).prop('disabled', true);
                    } else {
                        $(this).prop('disabled', false);
                    }
                });
            }
            
            // Add property button handler
            $('#add-property-btn').on('click', function() {
                const currentVaultId = $('#node-input-vault').val() || node.vault;
                addPropertyRow('', '', '', currentVaultId);
                // Trigger validation after adding row
                setTimeout(function() {
                    if (node._validateAndUpdateButton) {
                        node._validateAndUpdateButton();
                    }
                }, 50);
            });
            
            // Function to load properties for current vault
            function loadPropertiesForCurrentVault() {
                const selectedVaultId = $('#node-input-vault').val() || node.vault;
                
                if (!selectedVaultId) {
                    // No vault selected, add one empty row
                    addPropertyRow('', '', '', null);
                    return;
                }
                
                // Clear and reload rows
                $('#properties-list').empty();
                propertyRowCount = 0;
                
                if (node.properties && node.properties.length > 0) {
                    node.properties.forEach(prop => {
                        addPropertyRow(prop.group, prop.property, prop.output, selectedVaultId);
                    });
                } else {
                    addPropertyRow('', '', '', selectedVaultId);
                }
            }
            
            // Reload properties when vault changes
            $('#node-input-vault').on('change', function() {
                loadPropertiesForCurrentVault();
            });
            
            // Load properties immediately if vault is already set, otherwise wait for change event
            if (node.vault) {
                loadPropertiesForCurrentVault();
            } else {
                // New node, add one empty row
                addPropertyRow('', '', '', null);
            }
            
            // Validation function that updates Done button state and row indicators
            node._validateAndUpdateButton = function() {
                const doneButton = $('#node-dialog-ok');
                let validPropertyCount = 0;
                let hasPartialRow = false;
                
                $('#properties-list .property-row').each(function() {
                    const row = $(this);
                    const group = row.find('select').eq(0).val();
                    const property = row.find('select').eq(1).val();
                    const outputInput = row.find('.property-output');
                    const outputValue = outputInput.length > 0 ? outputInput.typedInput('value') : '';
                    const validationIcon = row.find('.property-validation-icon');
                    
                    // Check if row has any value filled
                    const hasAnyValue = group || property || outputValue;
                    
                    if (hasAnyValue) {
                        // Check if all fields are filled
                        if (group && property && outputValue) {
                            validPropertyCount++;
                            // Clear error indicator
                            row.removeClass('validation-error');
                            validationIcon.html('');
                        } else {
                            hasPartialRow = true;
                            // Show error indicator
                            row.addClass('validation-error');
                            validationIcon.html('<i class="fa fa-exclamation-triangle"></i>');
                        }
                    } else {
                        // Empty row - clear indicators
                        row.removeClass('validation-error');
                        validationIcon.html('');
                    }
                });
                
                // Enable button only if we have at least one valid property and no partial rows
                const isValid = validPropertyCount > 0 && !hasPartialRow;
                
                if (isValid) {
                    doneButton.prop('disabled', false).removeClass('disabled');
                } else {
                    doneButton.prop('disabled', true).addClass('disabled');
                }
                
                return isValid;
            };
            
            // Attach validation to all select changes
            $('#properties-list').on('change', 'select', function() {
                node._validateAndUpdateButton();
            });
            
            // Initial validation
            setTimeout(function() {
                node._validateAndUpdateButton();
            }, 100);
        },
        oneditcancel: function() {
            // Remove validation event handlers
            $('#properties-list').off('change');
            // Clean up validation function
            delete this._validateAndUpdateButton;
            // Re-enable Done button
            $('#node-dialog-ok').prop('disabled', false).removeClass('disabled');
        },
        oneditsave: function() {
            // Collect valid properties
            const properties = [];
            
            $('#properties-list .property-row').each(function() {
                const row = $(this);
                const group = row.find('select').eq(0).val();
                const property = row.find('select').eq(1).val();
                const outputInput = row.find('.property-output');
                const outputValue = outputInput.length > 0 ? outputInput.typedInput('value') : '';
                
                if (group && property && outputValue) {
                    const outputType = outputInput.typedInput('type');
                    properties.push({
                        group: group,
                        property: property,
                        output: outputType + '.' + outputValue
                    });
                }
            });
            
            this.properties = properties;
            
            // Remove validation event handlers
            $('#properties-list').off('change');
            // Clean up validation function
            delete this._validateAndUpdateButton;
        }
    });
</script>

<script type="text/html" data-template-name="vault">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    <div class="form-row">
        <label for="node-input-vault"><i class="fa fa-lock"></i> Vault</label>
        <input type="text" id="node-input-vault">
    </div>
    <div class="form-row">
        <label style="width: 100%;"><i class="fa fa-list"></i> Properties to Retrieve</label>
        <div class="vault-properties-header">
            <div>Group</div>
            <div>Property</div>
            <div>Save to</div>
            <div></div>
        </div>
        <div id="properties-list"></div>
        <button type="button" id="add-property-btn" class="red-ui-button" style="margin-top: 10px;">
            <i class="fa fa-plus"></i> Add Property
        </button>
    </div>
    <div class="form-tips">
        <strong>Purpose:</strong> Centrally store and retrieve configuration values. <strong>How to use:</strong> Select a group, choose a property from that group, and specify where to save it (msg/flow/global context). Perfect for credentials, API endpoints, feature flags, and environment-specific settings - develop with test values, deploy with production values without modifying flows.
    </div>
</script>

<script type="text/html" data-help-name="vault">
    <p>Retrieves configuration values from vault groups and saves them to message properties, flow context, or global context. Perfect for centralizing credentials, API endpoints, feature flags, and any other configuration data your flows need.</p>
    
    <h3>Configuration</h3>
    <p>Configure one or more property retrievals. Each row specifies:</p>
    <ul>
        <li><strong>Group:</strong> The vault group (logical grouping of related settings)</li>
        <li><strong>Property:</strong> The specific property to retrieve from that group</li>
        <li><strong>Save to:</strong> Where to save the value - supports:
            <ul>
                <li><code>msg</code> - Message property for per-message data (e.g., <code>msg.apiKey</code>)</li>
                <li><code>flow</code> - Flow context for settings shared across nodes (e.g., <code>flow.baseUrl</code>)</li>
                <li><code>global</code> - Global context for settings shared across flows (e.g., <code>global.dbHost</code>)</li>
            </ul>
        </li>
    </ul>
    
    <h3>Inputs</h3>
    <dl class="message-properties">
        <dt>any</dt>
        <dd>The node processes any incoming message and adds the configured properties based on your settings.</dd>
    </dl>
    
    <h3>Outputs</h3>
    <p>The node adds the retrieved property values to the configured contexts.</p>
    <dl class="message-properties">
        <dt>msg.{property} <span class="property-type">any</span></dt>
        <dd>Properties configured for <code>msg</code> context are added to the message.</dd>
        <dt>flow.{property} <span class="property-type">any</span></dt>
        <dd>Properties configured for <code>flow</code> context are stored in flow context.</dd>
        <dt>global.{property} <span class="property-type">any</span></dt>
        <dd>Properties configured for <code>global</code> context are stored in global context.</dd>
    </dl>
    
    <h3>Details</h3>
    <p>This node retrieves individual configuration values from vault groups and sets them directly to your chosen context. You can retrieve multiple properties from the same or different groups in a single node.</p>
    
    <p><strong>Key Benefits:</strong></p>
    <ul>
        <li>No function node needed - configuration retrieved automatically</li>
        <li>Environment-agnostic flows - develop with test settings, deploy with production settings</li>
        <li>Feature flag control - enable/disable flows dynamically</li>
        <li>Single point of configuration change</li>
    </ul>
    
    <p>The node will generate an error if:</p>
    <ul>
        <li>No vault-config node is configured</li>
        <li>A specified group is not found in the vault</li>
        <li>A specified property is not found in the group</li>
    </ul>
    
    <h3>Example 1: API Integration</h3>
    <p><strong>Vault Configuration:</strong></p>
    <pre>{
  "apiService": {
    "baseUrl": "https://api.production.com",
    "apiKey": "sk_live_abc123",
    "timeout": 30000
  }
}</pre>
    
    <p><strong>Node Configuration:</strong></p>
    <ul>
        <li>Group: apiService, Property: baseUrl, Save to: msg.baseUrl</li>
        <li>Group: apiService, Property: apiKey, Save to: msg.apiKey</li>
        <li>Group: apiService, Property: timeout, Save to: msg.timeout</li>
    </ul>
    
    <p><strong>Result:</strong> All API settings retrieved automatically - no hardcoded values in your flow.</p>
    
    <h3>Example 2: Feature Flags</h3>
    <p><strong>Vault Configuration:</strong></p>
    <pre>{
  "features": {
    "maintenanceMode": false,
    "useTestAPI": false
  }
}</pre>
    
    <p><strong>Node Configuration:</strong></p>
    <ul>
        <li>Group: features, Property: maintenanceMode, Save to: flow.maintenanceMode</li>
    </ul>
    
    <p><strong>Usage:</strong> Use a Switch node after the vault to check <code>flow.maintenanceMode</code> and enable/disable your flows dynamically.</p>
    
    <h3>Example 3: Environment Switching</h3>
    <p>Create separate vault-config nodes ("Test Settings" and "Production Settings") with the same group/property structure but different values. Switch between environments by changing which vault-config this node references - no flow changes needed.</p>
</script>

