<!-- Config Node: vault-config -->
<script type="text/javascript">
    RED.nodes.registerType('vault-config', {
        category: 'config',
        defaults: {
            name: { value: '', required: true }
        },
        credentials: {
            store: { type: 'text' }
        },
        label: function() {
            return this.name || 'vault-config';
        },
        oneditprepare: function() {
            const node = this;
            let entryCount = 0;
            let fieldCounters = {};
            
            // Parse existing vault store and populate entries
            function loadEntries() {
                // Get existing vault data
                let storeValue = (node.credentials && node.credentials.store) ? node.credentials.store : '{}';
                let entries = {};
                
                try {
                    if (storeValue && storeValue.trim() !== '' && storeValue !== '{}') {
                        entries = JSON.parse(storeValue);
                    }
                } catch (err) {
                    RED.notify('Failed to parse existing vault data: ' + err.message, 'warning');
                    entries = {};
                }
                
                // Clear existing entries UI
                $('#vault-entries-list').empty();
                entryCount = 0;
                fieldCounters = {};
                
                // Populate entries from vault
                let isFirstEntry = true;
                for (const key in entries) {
                    if (entries.hasOwnProperty(key)) {
                        // First entry should be expanded for better zero state
                        addEntryRow(key, entries[key], !isFirstEntry);
                        isFirstEntry = false;
                    }
                }
                
                // Add one empty row if no entries exist (expanded for zero state)
                if (entryCount === 0) {
                    addEntryRow('', {}, false);
                }
            }
            
            // Add a new vault entry (key with multiple fields)
            // collapseByDefault: true to collapse, false to show expanded
            function addEntryRow(key, credentialsObj, collapseByDefault) {
                const entryId = 'vault-entry-' + entryCount;
                entryCount++;
                fieldCounters[entryId] = 0;
                
                // Default to collapsed unless explicitly set to false
                if (collapseByDefault === undefined) {
                    collapseByDefault = true;
                }
                
                const entryContainer = $('<div>', {
                    id: entryId,
                    class: 'vault-entry-container',
                    style: 'margin-bottom: 15px; padding: 12px; border: 2px solid #ddd; border-radius: 6px; background-color: #f9f9f9;'
                });
                
                // Entry header with key, collapse/expand, clone, and delete buttons
                const headerRow = $('<div>', {
                    style: 'margin-bottom: 10px; display: flex; align-items: center; gap: 8px;'
                });
                
                // Collapse/Expand toggle
                const toggleBtn = $('<button>', {
                    type: 'button',
                    class: 'red-ui-button vault-toggle-btn',
                    style: 'min-width: 30px; padding: 4px 8px;'
                }).html('<i class="fa fa-chevron-right"></i>').on('click', function() {
                    const isCollapsed = entryContainer.hasClass('collapsed');
                    if (isCollapsed) {
                        entryContainer.removeClass('collapsed');
                        $(this).html('<i class="fa fa-chevron-down"></i>');
                        entryContainer.find('.vault-fields-list, .add-field-btn').show();
                    } else {
                        entryContainer.addClass('collapsed');
                        $(this).html('<i class="fa fa-chevron-right"></i>');
                        entryContainer.find('.vault-fields-list, .add-field-btn').hide();
                    }
                });
                
                const keyLabel = $('<label>', {
                    style: 'margin: 0; font-weight: bold; min-width: 60px;'
                }).text('Domain:');
                
                const keyInput = $('<input>', {
                    type: 'text',
                    class: 'vault-entry-key',
                    value: key,
                    placeholder: 'e.g. apiService',
                    style: 'flex: 1; max-width: 300px;'
                });
                
                const cloneEntryBtn = $('<button>', {
                    type: 'button',
                    class: 'red-ui-button',
                    title: 'Clone this domain'
                }).html('<i class="fa fa-copy"></i> Clone').on('click', function() {
                    // Clone the domain with new key
                    const originalKey = entryContainer.find('.vault-entry-key').val();
                    const newKey = originalKey + '_copy';
                    
                    // Collect all fields from current entry
                    const fields = {};
                    entryContainer.find('.vault-field-row').each(function() {
                        const fieldRow = $(this);
                        const fieldName = fieldRow.find('.vault-field-name').val();
                        const fieldType = fieldRow.find('.vault-field-value').typedInput('type');
                        const fieldValue = fieldRow.find('.vault-field-value').typedInput('value');
                        
                        if (fieldName) {
                            // Store raw value
                            fields[fieldName] = fieldValue;
                        }
                    });
                    
                    // Create new entry with cloned data (collapsed by default)
                    addEntryRow(newKey, fields, true);
                    RED.notify('Entry cloned as "' + newKey + '"', 'success');
                });
                
                const deleteEntryBtn = $('<button>', {
                    type: 'button',
                    class: 'red-ui-button',
                    style: 'margin-left: auto;'
                }).html('<i class="fa fa-trash"></i> Delete Domain').on('click', function() {
                    const entryKey = keyInput.val() || 'this entry';
                    const fieldCount = entryContainer.find('.vault-field-row').length;
                    
                    if (confirm('Delete "' + entryKey + '" with ' + fieldCount + ' field(s)?')) {
                        entryContainer.remove();
                        RED.notify('Entry deleted', 'success');
                    }
                });
                
                headerRow.append(toggleBtn).append(keyLabel).append(keyInput).append(cloneEntryBtn).append(deleteEntryBtn);
                
                // Fields list container
                const fieldsList = $('<div>', {
                    class: 'vault-fields-list',
                    style: 'margin-left: 20px; margin-top: 10px;'
                });
                
                // Add field button
                const addFieldBtn = $('<button>', {
                    type: 'button',
                    class: 'red-ui-button',
                    style: 'margin-top: 8px; margin-left: 20px;'
                }).html('<i class="fa fa-plus"></i> Add Field').on('click', function() {
                    addFieldRow(entryId, fieldsList, '', 'str', '');
                });
                
                // Assemble entry
                entryContainer.append(headerRow).append(fieldsList).append(addFieldBtn);
                $('#vault-entries-list').append(entryContainer);
                
                // Populate existing fields
                if (credentialsObj && typeof credentialsObj === 'object') {
                    for (const fieldName in credentialsObj) {
                        if (credentialsObj.hasOwnProperty(fieldName)) {
                            const value = credentialsObj[fieldName];
                            const type = detectType(value);
                            addFieldRow(entryId, fieldsList, fieldName, type, value);
                        }
                    }
                }
                
                // Add one empty field if no fields exist
                if (fieldsList.children().length === 0) {
                    addFieldRow(entryId, fieldsList, '', 'str', '');
                }
                
                // Collapse entry by default (if configured)
                if (collapseByDefault) {
                    entryContainer.addClass('collapsed');
                    toggleBtn.html('<i class="fa fa-chevron-right"></i>');
                    fieldsList.hide();
                    addFieldBtn.hide();
                } else {
                    // Entry starts expanded
                    toggleBtn.html('<i class="fa fa-chevron-down"></i>');
                    fieldsList.show();
                    addFieldBtn.show();
                }
            }
            
            // Detect type from value
            function detectType(value) {
                if (value === null || value === undefined) return 'str';
                if (typeof value === 'number') return 'num';
                if (typeof value === 'boolean') return 'bool';
                if (value instanceof Date) return 'date';
                if (Buffer.isBuffer(value)) return 'bin';
                if (typeof value === 'object') return 'json';
                return 'str';
            }
            
            // Add a credential field within an entry
            function addFieldRow(entryId, fieldsList, fieldName, fieldType, fieldValue) {
                const fieldId = entryId + '-field-' + fieldCounters[entryId];
                fieldCounters[entryId]++;
                
                const fieldRow = $('<div>', {
                    id: fieldId,
                    class: 'vault-field-row',
                    style: 'margin-bottom: 8px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; background-color: #fff; display: flex; align-items: center; gap: 8px;'
                });
                
                // Field name input
                const fieldNameLabel = $('<span>', {
                    style: 'min-width: 50px;'
                }).text('Field:');
                
                const fieldNameInput = $('<input>', {
                    type: 'text',
                    class: 'vault-field-name',
                    value: fieldName,
                    placeholder: 'e.g. username',
                    style: 'width: 150px;'
                });
                
                // TypedInput for value
                const valueInputContainer = $('<div>', {
                    style: 'flex: 1; min-width: 200px;'
                });
                
                const valueInput = $('<input>', {
                    type: 'text',
                    class: 'vault-field-value'
                });
                
                valueInputContainer.append(valueInput);
                
                // Validation indicator
                const validationIcon = $('<span>', {
                    class: 'validation-icon',
                    style: 'min-width: 20px; text-align: center;'
                }).html('');
                
                // Delete field button
                const deleteFieldBtn = $('<button>', {
                    type: 'button',
                    class: 'red-ui-button red-ui-button-small',
                    style: 'min-width: 30px;'
                }).html('<i class="fa fa-times"></i>').on('click', function() {
                    const fieldName = fieldNameInput.val() || 'this field';
                    if (fieldNameInput.val() || valueInput.typedInput('value')) {
                        if (confirm('Delete field "' + fieldName + '"?')) {
                            fieldRow.remove();
                        }
                    } else {
                        fieldRow.remove();
                    }
                });
                
                // Assemble field row
                fieldRow.append(fieldNameLabel).append(fieldNameInput).append(valueInputContainer).append(validationIcon).append(deleteFieldBtn);
                fieldsList.append(fieldRow);
                
                // Initialize TypedInput widget with password type
                valueInput.typedInput({
                    types: [
                        'str',
                        {
                            value: 'password',
                            label: 'password',
                            icon: 'fa fa-lock',
                            showLabel: false
                        },
                        'num',
                        'bool',
                        'json',
                        'bin',
                        'date'
                    ],
                    default: fieldType || 'str',
                    typeField: '#' + valueInput.attr('id') + '-type'
                });
                
                // For password type, set input to password type
                valueInput.on('change', function(event, type) {
                    if (type === true) return; // Skip initial trigger
                    const currentType = valueInput.typedInput('type');
                    const inputElement = valueInput.siblings('input.red-ui-typedInput-input');
                    if (currentType === 'password') {
                        inputElement.attr('type', 'password');
                    } else {
                        inputElement.attr('type', 'text');
                    }
                });
                
                // Set initial value and type
                valueInput.typedInput('type', fieldType || 'str');
                if (fieldValue !== undefined && fieldValue !== null) {
                    if (fieldType === 'json') {
                        valueInput.typedInput('value', JSON.stringify(fieldValue));
                    } else {
                        valueInput.typedInput('value', String(fieldValue));
                    }
                }
                
                // Add inline validation
                function validateField() {
                    const fieldName = fieldNameInput.val().trim();
                    const currentType = valueInput.typedInput('type');
                    const currentValue = valueInput.typedInput('value');
                    
                    let isValid = true;
                    let errorMsg = '';
                    
                    // Skip validation for empty fields
                    if (!fieldName && !currentValue) {
                        validationIcon.html('');
                        fieldRow.css('background-color', '');
                        return;
                    }
                    
                    // Validate field name
                    if (!fieldName && currentValue) {
                        isValid = false;
                        errorMsg = 'Field name required';
                    }
                    
                    // Validate value based on type
                    if (fieldName && currentValue) {
                        try {
                            switch (currentType) {
                                case 'num':
                                    if (isNaN(Number(currentValue))) {
                                        isValid = false;
                                        errorMsg = 'Invalid number';
                                    }
                                    break;
                                case 'bool':
                                    if (currentValue !== 'true' && currentValue !== 'false' && 
                                        currentValue !== true && currentValue !== false) {
                                        isValid = false;
                                        errorMsg = 'Must be true or false';
                                    }
                                    break;
                                case 'json':
                                    try {
                                        JSON.parse(currentValue);
                                    } catch (e) {
                                        isValid = false;
                                        errorMsg = 'Invalid JSON: ' + e.message;
                                    }
                                    break;
                            }
                        } catch (e) {
                            isValid = false;
                            errorMsg = 'Validation error';
                        }
                    }
                    
                    // Update UI
                    if (isValid && fieldName && currentValue) {
                        validationIcon.html('<i class="fa fa-check" style="color: green;" title="Valid"></i>');
                        fieldRow.css('background-color', '');
                    } else if (!isValid) {
                        validationIcon.html('<i class="fa fa-exclamation-triangle" style="color: #d9534f;" title="' + errorMsg + '"></i>');
                        fieldRow.css('background-color', '#fff3f3');
                    } else {
                        validationIcon.html('');
                        fieldRow.css('background-color', '');
                    }
                }
                
                // Attach validation to field name input
                fieldNameInput.on('input', validateField);
                
                // Attach validation to value changes
                valueInput.on('change', function() {
                    setTimeout(validateField, 100);
                });
                
                // Run initial validation
                setTimeout(validateField, 100);
            }
            
            // Add entry button handler
            $('#vault-add-entry').on('click', function() {
                // New entries should be expanded so user can immediately fill them
                addEntryRow('', {}, false);
            });
            
            // Load existing entries
            loadEntries();
        },
        oneditsave: function() {
            const vault = {};
            let hasError = false;
            
            // Collect all entries from UI
            $('.vault-entry-container').each(function() {
                const entryContainer = $(this);
                const key = entryContainer.find('.vault-entry-key').val().trim();
                
                // Skip entries with empty key and no fields
                const hasFields = entryContainer.find('.vault-field-row').length > 0;
                if (key === '' && !hasFields) {
                    return; // Skip this entry
                }
                
                // Validate key is provided
                if (key === '') {
                    RED.notify('Entry with empty key found. Please provide a key or delete the entry.', 'error');
                    hasError = true;
                    return false;
                }
                
                // Check for duplicate keys
                if (vault.hasOwnProperty(key)) {
                    RED.notify('Duplicate key found: "' + key + '". Keys must be unique.', 'error');
                    hasError = true;
                    return false;
                }
                
                // Collect all fields within this entry
                const credentials = {};
                let hasFieldError = false;
                
                entryContainer.find('.vault-field-row').each(function() {
                    const fieldRow = $(this);
                    const fieldName = fieldRow.find('.vault-field-name').val().trim();
                    const valueInput = fieldRow.find('.vault-field-value');
                    
                    // Skip empty fields
                    if (fieldName === '' && valueInput.typedInput('value') === '') {
                        return; // Skip this field
                    }
                    
                    // Validate field name is provided
                    if (fieldName === '') {
                        RED.notify('Entry "' + key + '" has a field with no name. Please provide a field name or delete the field.', 'error');
                        hasFieldError = true;
                        return false;
                    }
                    
                    // Check for duplicate field names within this entry
                    if (credentials.hasOwnProperty(fieldName)) {
                        RED.notify('Entry "' + key + '" has duplicate field name: "' + fieldName + '".', 'error');
                        hasFieldError = true;
                        return false;
                    }
                    
                    // Get value and type from TypedInput
                    const fieldType = valueInput.typedInput('type');
                    let fieldValue = valueInput.typedInput('value');
                    
                    // Convert value based on type
                    try {
                        switch (fieldType) {
                            case 'num':
                                fieldValue = Number(fieldValue);
                                if (isNaN(fieldValue)) {
                                    throw new Error('Invalid number');
                                }
                                break;
                            case 'bool':
                                if (fieldValue === 'true' || fieldValue === true) {
                                    fieldValue = true;
                                } else if (fieldValue === 'false' || fieldValue === false) {
                                    fieldValue = false;
                                } else {
                                    throw new Error('Invalid boolean (must be true or false)');
                                }
                                break;
                            case 'json':
                                fieldValue = JSON.parse(fieldValue);
                                break;
                            case 'date':
                                // TypedInput for date returns timestamp
                                fieldValue = Number(fieldValue);
                                break;
                            case 'bin':
                                // Store as base64 string for Buffer
                                fieldValue = fieldValue;
                                break;
                            case 'password':
                            case 'str':
                            default:
                                // Keep as string (password stored same as str, just masked in UI)
                                break;
                        }
                        
                        credentials[fieldName] = fieldValue;
                    } catch (err) {
                        RED.notify('Invalid value for field "' + fieldName + '" in entry "' + key + '": ' + err.message, 'error');
                        hasFieldError = true;
                        return false;
                    }
                });
                
                if (hasFieldError) {
                    hasError = true;
                    return false;
                }
                
                vault[key] = credentials;
            });
            
            if (hasError) {
                return false;
            }
            
            // Save vault as JSON string
            $('#node-config-input-store').val(JSON.stringify(vault));
        }
    });
</script>

<script type="text/html" data-template-name="vault-config">
    <div class="form-row">
        <label for="node-config-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-config-input-name" placeholder="Vault name">
    </div>
    
    <div class="form-row">
        <label style="width: 100%;"><i class="fa fa-lock"></i> Vault Entries</label>
        <div id="vault-entries-list" style="margin-top: 10px; width: 100%; max-height: 500px; overflow-y: auto;"></div>
    </div>
    
    <div class="form-row">
        <button type="button" id="vault-add-entry" class="red-ui-button">
            <i class="fa fa-plus"></i> Add Domain
        </button>
    </div>
    
    <!-- Hidden field to store the actual JSON -->
    <input type="hidden" id="node-config-input-store">
    
    <div class="form-tips">
        <strong>What is this?</strong> This configuration node stores your settings in one secure, encrypted location. No external dependencies - uses Node-RED's built-in encryption.
        <br><br>
        <strong>How it works:</strong> Organize settings into <strong>Domains</strong> (logical groups) containing <strong>Properties</strong> (individual values).
        <br><br>
        <strong>Example:</strong> Domain "apiService" might contain properties: baseUrl ("https://api.example.com"), apiKey (your key), timeout (30000). Use <strong>password</strong> type for sensitive values to mask them in the editor.
    </div>
</script>

<script type="text/html" data-help-name="vault-config">
    <p>Configuration node for centralized storage of credentials, API endpoints, database settings, feature flags, and any other configuration values. All values are encrypted using Node-RED's built-in credential system with no external dependencies.</p>
    
    <h3>Properties</h3>
    <dl class="message-properties">
        <dt>Name <span class="property-type">string</span></dt>
        <dd>A descriptive name for this vault instance (e.g., "Production Settings", "Test Configuration").</dd>
        
        <dt>Domains <span class="property-type">array</span></dt>
        <dd>A list of configuration domains. Each domain groups related settings:
            <ul>
                <li><strong>Domain:</strong> A logical grouping (e.g., "apiService", "database", "features")</li>
                <li><strong>Properties:</strong> Multiple properties with:
                    <ul>
                        <li><strong>Property Name:</strong> Setting name (e.g., "baseUrl", "timeout", "enabled")</li>
                        <li><strong>Type:</strong> Data type (str, password, num, bool, json, bin, date)</li>
                        <li><strong>Value:</strong> The configuration value (all types encrypted at rest)</li>
                    </ul>
                </li>
            </ul>
        </dd>
    </dl>
    
    <h3>Supported Types</h3>
    <ul>
        <li><strong>str</strong> - Text values (URLs, hostnames, usernames, tokens)</li>
        <li><strong>password</strong> - Masked input for passwords, API keys, secrets</li>
        <li><strong>num</strong> - Numbers (ports, timeouts, thresholds, limits)</li>
        <li><strong>bool</strong> - Boolean flags (enabled/disabled, feature flags)</li>
        <li><strong>json</strong> - Complex data (nested objects, arrays, configurations)</li>
        <li><strong>bin</strong> - Binary data (certificates, encoded keys)</li>
        <li><strong>date</strong> - Timestamps (expiration dates, schedule times)</li>
    </ul>
    <p><strong>Note:</strong> All values are encrypted at rest using Node-RED's built-in encryption. No external dependencies required. Use <strong>password</strong> type for masked editor input.</p>
    
    <h3>Details</h3>
    <p>This node stores all configuration values in a single encrypted field using Node-RED's built-in credential encryption. The vault content is stored in <code>flows_cred.json</code> and never appears in plain text in <code>flows.json</code>.</p>
    
    <p>The vault is <strong>read-only at runtime</strong>. To add, modify, or delete configuration values, edit this configuration node and redeploy the flow.</p>
    
    <p><strong>Use Cases:</strong></p>
    <ul>
        <li>Store credentials (usernames, passwords, API keys)</li>
        <li>Manage API endpoints and base URLs</li>
        <li>Configure database connection settings</li>
        <li>Control feature flags and environment settings</li>
        <li>Set operational thresholds and timeouts</li>
        <li>Maintain separate configurations for dev/staging/production</li>
    </ul>
    
    <h3>Usage</h3>
    <ol>
        <li>Click <strong>"Add Domain"</strong> to create a new vault domain</li>
        <li>Enter a unique domain name (e.g., "apiService", "database")</li>
        <li>Click <strong>"Add Field"</strong> to add properties within the domain</li>
        <li>For each property, enter:
            <ul>
                <li>Property name (e.g., "username", "password", "port")</li>
                <li>Type from dropdown (str, password, num, bool, json, bin, date)</li>
                <li>Value (visible in editor, encrypted when saved)</li>
            </ul>
        </li>
        <li>Use <strong>"Ã—"</strong> to remove individual properties or <strong>"Delete Domain"</strong> for entire domains</li>
        <li>Click <strong>"Update"</strong> to validate and save all changes</li>
    </ol>
    
    <h3>Example: API Service Configuration</h3>
    <p>Domain: <code>apiService</code></p>
    <ul>
        <li>Property: <code>baseUrl</code>, Type: <code>str</code>, Value: <code>https://api.production.com</code></li>
        <li>Property: <code>apiKey</code>, Type: <code>password</code>, Value: <code>sk_live_abc123</code></li>
        <li>Property: <code>timeout</code>, Type: <code>num</code>, Value: <code>30000</code></li>
        <li>Property: <code>retryEnabled</code>, Type: <code>bool</code>, Value: <code>true</code></li>
    </ul>
    
    <h3>Example: Feature Flags</h3>
    <p>Domain: <code>features</code></p>
    <ul>
        <li>Property: <code>maintenanceMode</code>, Type: <code>bool</code>, Value: <code>false</code></li>
        <li>Property: <code>debugLogging</code>, Type: <code>bool</code>, Value: <code>false</code></li>
        <li>Property: <code>rateLimitPerMinute</code>, Type: <code>num</code>, Value: <code>100</code></li>
        <li>Property: <code>allowedRegions</code>, Type: <code>json</code>, Value: <code>["us-east","eu-west"]</code></li>
    </ul>
</script>


<!-- Runtime Node: vault -->
<script type="text/javascript">
    RED.nodes.registerType('vault', {
        category: 'function',
        color: '#3FADB5',
        defaults: {
            name: { value: '' },
            vault: { value: '', type: 'vault-config', required: true },
            properties: { value: [] }
        },
        inputs: 1,
        outputs: 1,
        icon: 'font-awesome/fa-key',
        label: function() {
            return this.name || 'vault';
        },
        labelStyle: function() {
            return this.name ? 'node_label_italic' : '';
        },
        oneditprepare: function() {
            const node = this;
            let propertyRowCount = 0;
            
            // Load available domains from selected vault
            function loadAvailableDomains() {
                const vaultId = $('#node-input-vault').val();
                if (!vaultId) return [];
                
                const vaultNode = RED.nodes.node(vaultId);
                if (!vaultNode || !vaultNode.credentials || !vaultNode.credentials.store) {
                    return [];
                }
                
                try {
                    const vault = JSON.parse(vaultNode.credentials.store);
                    return Object.keys(vault);
                } catch (err) {
                    return [];
                }
            }
            
            // Load available properties for a given domain
            function loadPropertiesForDomain(domainName) {
                const vaultId = $('#node-input-vault').val();
                if (!vaultId || !domainName) return [];
                
                const vaultNode = RED.nodes.node(vaultId);
                if (!vaultNode || !vaultNode.credentials || !vaultNode.credentials.store) {
                    return [];
                }
                
                try {
                    const vault = JSON.parse(vaultNode.credentials.store);
                    if (vault[domainName] && typeof vault[domainName] === 'object') {
                        return Object.keys(vault[domainName]);
                    }
                    return [];
                } catch (err) {
                    return [];
                }
            }
            
            // Create domain dropdown
            function createDomainSelect(selectedDomain) {
                const select = $('<select>', { style: 'width: 100%;' });
                const domains = loadAvailableDomains();
                
                select.append($('<option>', { value: '' }).text('-- select domain --'));
                domains.forEach(domain => {
                    select.append($('<option>', { value: domain, selected: domain === selectedDomain }).text(domain));
                });
                
                return select;
            }
            
            // Create property dropdown
            function createPropertySelect(domainName, selectedProperty) {
                const select = $('<select>', { style: 'width: 100%;' });
                const properties = loadPropertiesForDomain(domainName);
                
                select.append($('<option>', { value: '' }).text('-- select property --'));
                properties.forEach(prop => {
                    select.append($('<option>', { value: prop, selected: prop === selectedProperty }).text(prop));
                });
                
                return select;
            }
            
            // Add a property row
            function addPropertyRow(domain, property, output) {
                const rowId = 'property-row-' + propertyRowCount++;
                
                const row = $('<div>', {
                    id: rowId,
                    class: 'property-row',
                    style: 'display: grid; grid-template-columns: 2fr 2fr 2fr 50px; gap: 10px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #fff; margin-bottom: 8px; align-items: center;'
                });
                
                // Domain dropdown
                const domainSelect = createDomainSelect(domain);
                row.append(domainSelect);
                
                // Property dropdown
                const propertySelect = createPropertySelect(domain, property);
                row.append(propertySelect);
                
                // Update property dropdown when domain changes
                domainSelect.on('change', function() {
                    const newDomain = $(this).val();
                    const newPropertySelect = createPropertySelect(newDomain, '');
                    propertySelect.replaceWith(newPropertySelect);
                    propertySelect.off();
                    
                    // Update output field when new property is selected
                    // IMPORTANT: Wait for TypedInput initialization before attaching handler
                    setTimeout(function() {
                        newPropertySelect.on('change', function() {
                            const propValue = $(this).val();
                            const outputInput = row.find('.property-output');
                            if (propValue && !outputInput.data('userModified')) {
                                outputInput.typedInput('value', propValue);
                            }
                        });
                    }, 10); // Small delay to ensure TypedInput is ready
                });
                
                // Output field with TypedInput (msg/flow/global)
                const outputInput = $('<input>', {
                    type: 'text',
                    class: 'property-output',
                    style: 'width: 100%;'
                });
                
                row.append(outputInput);
                
                // Initialize TypedInput after adding to DOM
                setTimeout(function() {
                    outputInput.typedInput({
                        types: ['msg', 'flow', 'global'],
                        default: 'msg'
                    });
                    
                    // Set initial value
                    if (output) {
                        // Parse output like "msg.username" or "flow.apiKey"
                        const parts = output.split('.');
                        if (parts.length >= 2 && (parts[0] === 'msg' || parts[0] === 'flow' || parts[0] === 'global')) {
                            outputInput.typedInput('type', parts[0]);
                            outputInput.typedInput('value', parts.slice(1).join('.'));
                        } else {
                            outputInput.typedInput('value', property || '');
                        }
                    } else {
                        outputInput.typedInput('value', property || '');
                    }
                    
                    // Track manual modifications
                    outputInput.on('change', function() {
                        $(this).data('userModified', true);
                    });
                    
                    // Auto-fill output when property is selected
                    // IMPORTANT: This must be inside setTimeout to ensure TypedInput is initialized
                    propertySelect.on('change', function() {
                        const propValue = $(this).val();
                        if (propValue && !outputInput.data('userModified')) {
                            outputInput.typedInput('value', propValue);
                        }
                    });
                }, 0);
                
                // Delete button
                const deleteBtn = $('<button>', {
                    type: 'button',
                    class: 'red-ui-button property-delete-btn',
                    style: 'padding: 6px 10px; font-size: 12px;'
                }).html('<i class="fa fa-times"></i>').on('click', function() {
                    row.remove();
                    updateDeleteButtons();
                });
                
                row.append(deleteBtn);
                
                $('#properties-list').append(row);
                updateDeleteButtons();
            }
            
            // Update delete button states
            function updateDeleteButtons() {
                const rows = $('.property-row');
                $('.property-delete-btn').each(function(index) {
                    if (rows.length === 1) {
                        $(this).prop('disabled', true);
                    } else {
                        $(this).prop('disabled', false);
                    }
                });
            }
            
            // Add property button handler
            $('#add-property-btn').on('click', function() {
                addPropertyRow('', '', '');
            });
            
            // Reload properties when vault changes
            $('#node-input-vault').on('change', function() {
                // Clear and reload rows
                $('#properties-list').empty();
                propertyRowCount = 0;
                
                if (node.properties && node.properties.length > 0) {
                    node.properties.forEach(prop => {
                        addPropertyRow(prop.domain, prop.property, prop.output);
                    });
                } else {
                    addPropertyRow('', '', '');
                }
            });
            
            // Load existing properties
            if (node.properties && node.properties.length > 0) {
                node.properties.forEach(prop => {
                    addPropertyRow(prop.domain, prop.property, prop.output);
                });
            } else {
                // Add one empty row by default
                addPropertyRow('', '', '');
            }
        },
        oneditsave: function() {
            const properties = [];
            
            $('#properties-list .property-row').each(function() {
                const row = $(this);
                const domain = row.find('select').eq(0).val();
                const property = row.find('select').eq(1).val();
                const outputInput = row.find('.property-output');
                
                if (domain && property && outputInput.length > 0) {
                    const outputType = outputInput.typedInput('type');
                    const outputValue = outputInput.typedInput('value');
                    
                    if (outputValue) {
                        properties.push({
                            domain: domain,
                            property: property,
                            output: outputType + '.' + outputValue
                        });
                    }
                }
            });
            
            this.properties = properties;
        }
    });
</script>

<script type="text/html" data-template-name="vault">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    <div class="form-row">
        <label for="node-input-vault"><i class="fa fa-lock"></i> Vault</label>
        <input type="text" id="node-input-vault">
    </div>
    <div class="form-row">
        <label style="width: 100%;"><i class="fa fa-list"></i> Properties to Retrieve</label>
        <div style="display: grid; grid-template-columns: 2fr 2fr 2fr 50px; gap: 10px; padding: 10px 12px; background: #e8e8e8; font-weight: 600; color: #555; border-radius: 4px 4px 0 0; margin-bottom: 5px;">
            <div>Domain</div>
            <div>Property</div>
            <div>Save to</div>
            <div></div>
        </div>
        <div id="properties-list"></div>
        <button type="button" id="add-property-btn" class="red-ui-button" style="margin-top: 10px;">
            <i class="fa fa-plus"></i> Add Property
        </button>
    </div>
    <div class="form-tips">
        <strong>How it works:</strong> Each row retrieves one configuration value from a vault domain and saves it to the specified context (msg, flow, or global). Use for credentials, API endpoints, feature flags, or any settings. Perfect for environment-agnostic flows - develop with test settings, deploy with production settings without changing your flow logic.
    </div>
</script>

<script type="text/html" data-help-name="vault">
    <p>Retrieves configuration values from vault domains and saves them to message properties, flow context, or global context. Perfect for centralizing credentials, API endpoints, feature flags, and any other configuration data your flows need.</p>
    
    <h3>Configuration</h3>
    <p>Configure one or more property retrievals. Each row specifies:</p>
    <ul>
        <li><strong>Domain:</strong> The vault domain (logical grouping of related settings)</li>
        <li><strong>Property:</strong> The specific property to retrieve from that domain</li>
        <li><strong>Save to:</strong> Where to save the value - supports:
            <ul>
                <li><code>msg</code> - Message property for per-message data (e.g., <code>msg.apiKey</code>)</li>
                <li><code>flow</code> - Flow context for settings shared across nodes (e.g., <code>flow.baseUrl</code>)</li>
                <li><code>global</code> - Global context for settings shared across flows (e.g., <code>global.dbHost</code>)</li>
            </ul>
        </li>
    </ul>
    
    <h3>Inputs</h3>
    <dl class="message-properties">
        <dt>any</dt>
        <dd>The node processes any incoming message and adds the configured properties based on your settings.</dd>
    </dl>
    
    <h3>Outputs</h3>
    <p>The node adds the retrieved property values to the configured contexts.</p>
    <dl class="message-properties">
        <dt>msg.{property} <span class="property-type">any</span></dt>
        <dd>Properties configured for <code>msg</code> context are added to the message.</dd>
        <dt>flow.{property} <span class="property-type">any</span></dt>
        <dd>Properties configured for <code>flow</code> context are stored in flow context.</dd>
        <dt>global.{property} <span class="property-type">any</span></dt>
        <dd>Properties configured for <code>global</code> context are stored in global context.</dd>
    </dl>
    
    <h3>Details</h3>
    <p>This node retrieves individual configuration values from vault domains and sets them directly to your chosen context. You can retrieve multiple properties from the same or different domains in a single node.</p>
    
    <p><strong>Key Benefits:</strong></p>
    <ul>
        <li>No function node needed - configuration retrieved automatically</li>
        <li>Environment-agnostic flows - develop with test settings, deploy with production settings</li>
        <li>Feature flag control - enable/disable flows dynamically</li>
        <li>Single point of configuration change</li>
    </ul>
    
    <p>The node will generate an error if:</p>
    <ul>
        <li>No vault-config node is configured</li>
        <li>A specified domain is not found in the vault</li>
        <li>A specified property is not found in the domain</li>
    </ul>
    
    <h3>Example 1: API Integration</h3>
    <p><strong>Vault Configuration:</strong></p>
    <pre>{
  "apiService": {
    "baseUrl": "https://api.production.com",
    "apiKey": "sk_live_abc123",
    "timeout": 30000
  }
}</pre>
    
    <p><strong>Node Configuration:</strong></p>
    <ul>
        <li>Domain: apiService, Property: baseUrl, Save to: msg.baseUrl</li>
        <li>Domain: apiService, Property: apiKey, Save to: msg.apiKey</li>
        <li>Domain: apiService, Property: timeout, Save to: msg.timeout</li>
    </ul>
    
    <p><strong>Result:</strong> All API settings retrieved automatically - no hardcoded values in your flow.</p>
    
    <h3>Example 2: Feature Flags</h3>
    <p><strong>Vault Configuration:</strong></p>
    <pre>{
  "features": {
    "maintenanceMode": false,
    "useTestAPI": false
  }
}</pre>
    
    <p><strong>Node Configuration:</strong></p>
    <ul>
        <li>Domain: features, Property: maintenanceMode, Save to: flow.maintenanceMode</li>
    </ul>
    
    <p><strong>Usage:</strong> Use a Switch node after the vault to check <code>flow.maintenanceMode</code> and enable/disable your flows dynamically.</p>
    
    <h3>Example 3: Environment Switching</h3>
    <p>Create separate vault-config nodes ("Test Settings" and "Production Settings") with the same domain/property structure but different values. Switch between environments by changing which vault-config this node references - no flow changes needed.</p>
</script>

